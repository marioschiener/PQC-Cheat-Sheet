% !TeX root = PQC_Cheat_Sheet.tex

% Author: Mario Schiener, 2024
% LinkedIn: https://www.linkedin.com/in/mario-schiener/
% Github: https://github.com/marioschiener

% ============================================================================================================
% Explanations
% ============================================================================================================
\begin{minipage}[t]{0.4\textwidth} % left
    \vspace{-3mm}
    \begin{algorithmbox}{Symbols}
        \scriptsize
        {\bfseries  General color coding}\\[0.5\baselineskip]
        Best to Worst:
        \textcolor{themegreen}{$\blacksquare$}
        \textcolor{themeyellow}{$\blacksquare$}
        \textcolor{themeorange}{$\blacksquare$}
        \textcolor{themered}{$\blacksquare$}
        \textcolor{themered!65!black}{$\blacksquare$}\quad
        TBD: \textcolor{themeblue}{$\blacksquare$}\\[\baselineskip]

        {\bfseries  Symbols}
        \vspace{-0.5\baselineskip}
        \begin{tabbing}
            \textcolor{themegreydark}{\faExclamationCircle}\quad Recommendations differ depending on organization\\
            \=\textcolor{themegreydark}{\faSun[regular]}\quad Parameter set\hspace{3cm}
            \=\textcolor{themegreydark}{\faKey}\quad Key Generation\\
            \>\textcolor{themegreydark}{\faLock}\quad Encryption / Ciphertext
            \>\textcolor{themegreydark}{\faUnlock}\quad Decryption\\
            \>\textcolor{themegreydark}{\faPen}\quad Signing / Signature
            \>\textcolor{themegreydark}{\faQuestionCircle}\quad Verification\\
            \>\textcolor{themegreydark}{\faCalendar}\quad Not yet standardized by NIST
            \>\textcolor{themegreydark}{\faMicrochip}\quad CPU Cycles\\
            \>\textcolor{themegreydark}{\faCode}\quad Implementation Code
            \>\hspace{-0.5mm}\lettericon{themewhite}{themegreydark}{C}{1}\hspace{-2mm} Implementation complexity\\
            \>\lettericon{themewhite}{themegreydark}{S}{1}\hspace{-1mm} Implementation size
        \end{tabbing}

        {\bfseries Security categories of parameter sets}\\[0.5\baselineskip]
        \doubleicon{\montserratbold V}{\faSun[regular]}{themegreen}{0.6}
        \doubleicon{\montserratbold IV}{\faSun[regular]}{themeyellow}{0.6}
        \doubleicon{\montserratbold III}{\faSun[regular]}{themeorange}{0.6}
        \doubleicon{\montserratbold II}{\faSun[regular]}{themered}{0.6}
        \doubleicon[themewhite]{\montserratbold I}{\faSun[regular]}{themered!65!black}{0.6} NIST Security Categories V, IV, III, II, I\\[\baselineskip]

        Higher means more secure.\\[\baselineskip]

        {\bfseries Implementation complexity and size}\\[0.5\baselineskip]
        \tripleicon{\montserratbold L}{\faCode}{themegreen}{0.6}{\bfseries C}
        \tripleicon{\montserratbold M}{\faCode}{themeyellow}{0.6}{\bfseries C}
        \tripleicon{\montserratbold H}{\faCode}{themered}{0.6}{\bfseries C} Low/Medium/High implementation complexity\\
        \tripleicon{\montserratbold L}{\faCode}{themegreen}{0.6}{\bfseries S}
        \tripleicon{\montserratbold M}{\faCode}{themeyellow}{0.6}{\bfseries S}
        \tripleicon{\montserratbold H}{\faCode}{themered}{0.6}{\bfseries S} Low/Medium/High implementation size\\[\baselineskip]
        Lower is better.\\[\baselineskip]

        {\bfseries Rating scales for parameter sizes and performance}\\[0.5\baselineskip]
        Best to Worst: \textcolor{themegreen}{$\blacksquare$} $n\leq2$, \textcolor{themeyellow}{$\blacksquare$} $n\{3,4\}$, \textcolor{themeorange}{$\blacksquare$} $n\in\{5,6\}$, \textcolor{themered}{$\blacksquare$} $n\in\{7,8\}$, \textcolor{themered!65!black}{$\blacksquare$} $n\geq9$
        \begin{tabbing}
            \=\tripleicon{\montserratbold n}{\faMicrochip}{themegreylight!50}{0.6}{\faKey}
            \=$\mathcal{O}(5^n)$ CPU kilo cycles for key generation\\
            \=\tripleicon{\montserratbold n}{\faMicrochip}{themegreylight!50}{0.6}{\faPen}
            \=$\mathcal{O}(5^n)$ CPU kilo cycles for signing\\
            \=\tripleicon{\montserratbold n}{\faMicrochip}{themegreylight!50}{0.6}{\faQuestionCircle}
            \=$\mathcal{O}(5^n)$ CPU kilo cycles for signature verification\\
            \=\tripleicon{\montserratbold n}{\faMicrochip}{themegreylight!50}{0.6}{\faLock}
            \=$\mathcal{O}(5^n)$ CPU kilo cycles for encryption / key encapsulation\\
            \=\tripleicon{\montserratbold n}{\faMicrochip}{themegreylight!50}{0.6}{\faUnlock}
            \=$\mathcal{O}(5^n)$ CPU kilo cycles for decryption / key decapsulation\\
            \>\doubleicon{\montserratbold n}{\faPen}{themegreylight!50}{0.6}
            \>$\mathcal{O}(2^n)$ KB of signature size\\
            \>\doubleicon{\montserratbold n}{\faLock}{themegreylight!50}{0.6}
            \> $\mathcal{O}(2^n)$ KB of ciphertext size\\
            \>\doubleicon{\montserratbold n}{\faKey}{themegreylight!50}{0.6}
            \> $\mathcal{O}(2^{(n-5)})$ KB of signature algorithm public key size\\
            \>\doubleicon{\montserratbold n}{\faKey}{themegreylight!50}{0.6}
            \> $\mathcal{O}(2^n)$ KB of encryption algorithm public key size\\
        \end{tabbing}
        \vspace{-6mm}
    \end{algorithmbox}
\end{minipage}
\hfill
\begin{minipage}[t]{0.58\textwidth} % right
    \vspace{-3mm}
    \begin{algorithmbox}{How To Interpret This Cheat Sheet}
        \scriptsize
        {\bfseries The goal of this cheat sheet is to make it as easy as possible to figure out which algorithm to pick for a given use case. Algorithm ID cards break down algorithm parameter sets, their important values and performance characteristics. The cheat sheet is intended to help users primarily in technical roles, such as engineers, architects or software developers working with post-quantum cryptography.}\\[\baselineskip]

        The focus is to avoid giving specific numbers measured in bits, bytes or cycles as this makes makes comparing numbers across algorithms difficult. Instead, this complexity is simplified by only providing a
        {\bfseries color-coded number indicating the order of magnitude of each metric}.\\[\baselineskip]

        {\bfseries This approach prioritizes easy interpretation and comparability of metrics and in general quick informational gain over absolute precision of data -- remember this is a cheat sheet, not a standard! This document is not intended to replace the study of algorithm specifications. It just aims to point you in the right direction quickly.}\\[\baselineskip]

        The approach of focusing on orders of magnitude walks a fine line between treating too many things as ``equal'' and not simplifying things enough to be easy to read and compare. ``In the same order of magnitude'' usually refers to ``equal up to a factor of at most 10'', which is a very coarse way of comparing numbers. Treating metrics that differ by a factor of e.g. 9.9 as ``equal'' because 9.9 < 10 paints a distorted picture. In cryptography, factors of 5 or even 2 can make a significant difference in performance, both in theory and in practice. In order to still tease out the differences in metrics without throwing too many things together that actually differ significantly, this cheat sheet applies different scaling and ``orders of magnitude'' (i.e., not regarding base 10) for different metrics.\\[\baselineskip]


        It turns out that for {\bfseries metrics measured in (kilo) CPU cycle counts, i.e. algorithm performance, ``up to a factor of 5''} is a scale that is granular enough to work out the differences between algorithms while maintaining easy comparability. Those cycle counts heavily depend on the CPU used during measurement, hence the numbers need to be taken with a grain of salt, even if given exactly and not in terms of orders of magnitude.\\[\baselineskip]

        For {\bfseries signature and ciphertext sizes as well as key sizes, measuring numbers in kilobytes ``up to a factor of 2''} is well suited to work out the differences between algorithms while allowing for quick comparison. Specifically for signature public key sizes only, we offset the corresponding color coding by 5 orders of magnitude. This is because SLH-DSA has extremely small pubic keys compared to all other signature algorithms, which would extend the scale into negative numbers (e.g. for SLH-DSA-SHA2-128s, the public key has 32=2\textsuperscript{5} bytes, which corresponds to an order of magnitude of -5 when measuring in orders magnitude of factor 2 and in kilobytes). This phenomenon of algorithm metrics spanning a very large range of orders of (base 2) magnitudes does not occur to this extent for encryption algorithms, making an offset unnecessary.\\[\baselineskip]

        All values thus have a lower bound of 0. We do not limit the upper end of scales, but don't distinguish values greater than 10 anymore in terms of color coding. Please refer to the definitions on the left for symbol explanations, color coding and interpretation of numeric values.
        \vspace{0.7cm}
    \end{algorithmbox}
\end{minipage}
